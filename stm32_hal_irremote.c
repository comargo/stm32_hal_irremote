/**
  ******************************************************************************
  * @file     lib.c
  * @author   Auto-generated by STM32CubeIDE
  * @version  V1.0
  * @date     08/12/2021 21:02:36
  * @brief    Default under dev library file.
  ******************************************************************************
*/

/* Includes ------------------------------------------------------------------*/
#include "stm32_hal_irremote.h"
#include "decoders/decoders.h"

/** Functions ----------------------------------------------------------------*/
static TIM_TypeDef *GetTIMInstance(GPIO_TypeDef* gpio, uint32_t pin)
{
	switch((uintptr_t)gpio) {
#if defined(STM32F1)
	case GPIOA_BASE:
		if((pin & (GPIO_PIN_0|GPIO_PIN_1)) != 0)
			return TIM2;
// TIM3 do not support DMA channel!!!
//		if((pin & (GPIO_PIN_6|GPIO_PIN_7)) != 0)
//			return TIM3;
		break;
	case GPIOB_BASE:
		if((pin & (GPIO_PIN_6|GPIO_PIN_7)) != 0)
			return TIM4;
		break;
#else
#error "STM32 controller is not defined or not supported (yet)"
#endif
	}
	assert_param(0);
	return NULL;
}

static void EnableTIM(TIM_TypeDef *tim)
{
	switch((uintptr_t)tim) {
	case TIM2_BASE:
		__HAL_RCC_TIM2_CLK_ENABLE();
		break;
	case TIM3_BASE:
		__HAL_RCC_TIM3_CLK_ENABLE();
		break;
	case TIM4_BASE:
		__HAL_RCC_TIM4_CLK_ENABLE();
		break;
	}
}

static void EnableTIM_IRQ(TIM_TypeDef *tim)
{
  IRQn_Type irq;
  switch((uintptr_t)tim) {
  case TIM2_BASE:
    irq = TIM2_IRQn;
    break;
  case TIM3_BASE:
    irq = TIM3_IRQn;
    break;
  case TIM4_BASE:
    irq = TIM4_IRQn;
    break;
  default:
    return;
  }

  HAL_NVIC_SetPriority(irq, 0, 0);
  HAL_NVIC_EnableIRQ(irq);
}

static void EnableGPIO(GPIO_TypeDef* gpio)
{
	switch((uintptr_t)gpio) {
	case GPIOA_BASE:
		__HAL_RCC_GPIOA_CLK_ENABLE();
		break;
	case GPIOB_BASE:
		__HAL_RCC_GPIOB_CLK_ENABLE();
		break;
	}
}

static int GetTIMPrescaler()
{
	int ret = (HAL_RCC_GetPCLK2Freq()/1000000)*IR_USECPERTICK-1;
	if(ret < 0)
		return 0;
	return ret;
}

static void InitGPIO(struct CM_HAL_IRREMOTE *irremote)
{
	EnableGPIO(irremote->GPIOx);
	GPIO_InitTypeDef GPIO_InitStruct = { .Pin = irremote->GPIO_Pin, .Mode =
			GPIO_MODE_INPUT, .Pull = GPIO_NOPULL };
	HAL_GPIO_Init(irremote->GPIOx, &GPIO_InitStruct);
}

static void InitTIM(struct CM_HAL_IRREMOTE *irremote)
{
	TIM_HandleTypeDef *htim = &irremote->htim;
	htim->Instance = GetTIMInstance(irremote->GPIOx,
			irremote->GPIO_Pin);
	EnableTIM(htim->Instance);
	htim->Init.Prescaler = GetTIMPrescaler();
	htim->Init.CounterMode = TIM_COUNTERMODE_UP;
	htim->Init.Period = IR_GAP_TICKS; // 50 usec
	htim->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(htim) != HAL_OK) {
		assert_param(0);
	}
	TIM_ClockConfigTypeDef sClockSourceConfig = {
	    .ClockSource = TIM_CLOCKSOURCE_INTERNAL,
	    .ClockFilter = 0,
	    .ClockPolarity = 0,
			.ClockPrescaler = 0
	};
	if (HAL_TIM_ConfigClockSource(htim, &sClockSourceConfig) != HAL_OK) {
		assert_param(0);
	}
	if (HAL_TIM_IC_Init(htim) != HAL_OK) {
		assert_param(0);
	}
	TIM_SlaveConfigTypeDef sSlaveConfig = {
	    .SlaveMode = TIM_SLAVEMODE_RESET,
			.InputTrigger = TIM_TS_TI1FP1,
			.TriggerPolarity = TIM_INPUTCHANNELPOLARITY_FALLING,
			.TriggerFilter = 0,
			.TriggerPrescaler = 0
	};
	if (HAL_TIM_SlaveConfigSynchro(htim, &sSlaveConfig) != HAL_OK) {
		assert_param(0);
	}
	TIM_MasterConfigTypeDef sMasterConfig = {
	    .MasterOutputTrigger = TIM_TRGO_RESET,
	    .MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE
	};
	if (HAL_TIMEx_MasterConfigSynchronization(htim, &sMasterConfig) != HAL_OK) {
		assert_param(0);
	}
	TIM_IC_InitTypeDef sConfigIC = {
	    .ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING,
	    .ICSelection = TIM_ICSELECTION_DIRECTTI,
	    .ICPrescaler = TIM_ICPSC_DIV1,
	    .ICFilter = 0
	};
	if (HAL_TIM_IC_ConfigChannel(htim, &sConfigIC, TIM_CHANNEL_1) != HAL_OK) {
		assert_param(0);
	}
	sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
	sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
	if (HAL_TIM_IC_ConfigChannel(htim, &sConfigIC, TIM_CHANNEL_2) != HAL_OK) {
		assert_param(0);
	}

	EnableTIM_IRQ(htim->Instance);
}

static DMA_Channel_TypeDef *GetDMAInstance(TIM_TypeDef *tim, uint16_t DMAHandleIndex)
{
#if defined(STM32F1)
  switch((uintptr_t)tim)
  {
  case TIM2_BASE:
    switch(DMAHandleIndex) {
    case TIM_DMA_ID_CC1:
      return DMA1_Channel5;
    case TIM_DMA_ID_CC2:
      return DMA1_Channel7;
    default:
      return NULL;
    }
  case TIM4_BASE:
    switch(DMAHandleIndex) {
    case TIM_DMA_ID_CC1:
      return DMA1_Channel1;
    case TIM_DMA_ID_CC2:
      return DMA1_Channel4;
    default:
      return NULL;
    }
  default:
    return NULL;
  }
#endif
  return NULL;
}

static void EnableDMA_IRQ(DMA_Channel_TypeDef *dmaChannel)
{
  IRQn_Type irq;
#if defined(STM32F1)
  int dmaIndex = (((uintptr_t)dmaChannel) - DMA1_Channel1_BASE)/0x14;
  irq = DMA1_Channel1_IRQn+dmaIndex;
#endif
  HAL_NVIC_SetPriority(irq, 0, 0);
  HAL_NVIC_EnableIRQ(irq);
}

static void InitDMA(struct CM_HAL_IRREMOTE* irremote)
{
  __HAL_RCC_DMA1_CLK_ENABLE();

  irremote->dma_width.Instance = GetDMAInstance(irremote->htim.Instance, TIM_DMA_ID_CC1);
  irremote->dma_width.Init.Direction = DMA_PERIPH_TO_MEMORY;
  irremote->dma_width.Init.PeriphInc = DMA_PINC_DISABLE;
  irremote->dma_width.Init.MemInc = DMA_MINC_ENABLE;
  irremote->dma_width.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
  irremote->dma_width.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
  irremote->dma_width.Init.Mode = DMA_NORMAL;
  irremote->dma_width.Init.Priority = DMA_PRIORITY_LOW;
  if (HAL_DMA_Init(&irremote->dma_width) != HAL_OK)
  {
    assert_param(0);
  }
  __HAL_LINKDMA(&(irremote->htim),hdma[TIM_DMA_ID_CC1],irremote->dma_width);

  irremote->dma_pulse.Instance = GetDMAInstance(irremote->htim.Instance, TIM_DMA_ID_CC2);
  irremote->dma_pulse.Init.Direction = DMA_PERIPH_TO_MEMORY;
  irremote->dma_pulse.Init.PeriphInc = DMA_PINC_DISABLE;
  irremote->dma_pulse.Init.MemInc = DMA_MINC_ENABLE;
  irremote->dma_pulse.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
  irremote->dma_pulse.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
  irremote->dma_pulse.Init.Mode = DMA_NORMAL;
  irremote->dma_pulse.Init.Priority = DMA_PRIORITY_LOW;
  if (HAL_DMA_Init(&irremote->dma_pulse) != HAL_OK)
  {
    assert_param(0);
  }
  __HAL_LINKDMA(&(irremote->htim),hdma[TIM_DMA_ID_CC2],irremote->dma_pulse);

  EnableDMA_IRQ(irremote->dma_width.Instance);
  EnableDMA_IRQ(irremote->dma_pulse.Instance);

}

void CM_HAL_IRREMOTE_Init(struct CM_HAL_IRREMOTE* irremote)
{
	assert_param(IS_GPIO_ALL_INSTANCE(irremote->GPIOx));
	assert_param(IS_GPIO_PIN(irremote->GPIO_Pin));

	InitGPIO(irremote);
	InitTIM(irremote);
	InitDMA(irremote);
}

void CM_HAL_IRREMOTE_Start(struct CM_HAL_IRREMOTE* irremote)
{
	irremote->rcvstate = IRREMOTE_CAPTURE;
	irremote->rawlen = 0;
  __HAL_TIM_URS_ENABLE(&irremote->htim);
  HAL_TIM_IC_Start_DMA(&irremote->htim, TIM_CHANNEL_1, (uint32_t*)irremote->data_width, IRREMOTE_RAWBUF/2);
  HAL_TIM_IC_Start_DMA(&irremote->htim, TIM_CHANNEL_2, (uint32_t*)irremote->data_pulse, IRREMOTE_RAWBUF/2);
	HAL_TIM_Base_Start_IT(&irremote->htim);
}

void CM_HAL_IRREMOTE_Stop(struct CM_HAL_IRREMOTE* irremote)
{
  irremote->rcvstate = IRREMOTE_DONE;
  HAL_TIM_IC_Stop_DMA(&irremote->htim, TIM_CHANNEL_1);
  HAL_TIM_IC_Stop_DMA(&irremote->htim, TIM_CHANNEL_2);
  HAL_TIM_Base_Stop_IT(&irremote->htim);
}

static void PeriodElapsedCallback(struct CM_HAL_IRREMOTE *irremote)
{
  if(irremote->rcvstate == IRREMOTE_GAP) {
    CM_HAL_IRREMOTE_Stop(irremote);
    return;
  }

  if(__HAL_DMA_GET_COUNTER(irremote->htim.hdma[TIM_DMA_ID_CC1]) < IRREMOTE_RAWBUF/2) {
    irremote->rcvstate = IRREMOTE_GAP;
    HAL_TIM_GenerateEvent(&irremote->htim, TIM_EVENTSOURCE_CC1);
    HAL_TIM_GenerateEvent(&irremote->htim, TIM_EVENTSOURCE_UPDATE);
    return;
  }
}

void CM_HAL_IRREMOTE_IRQHandler(struct CM_HAL_IRREMOTE *irremote, IRQn_Type irq)
{
  if(irq == TIM2_IRQn || irq == TIM3_IRQn || irq == TIM4_IRQn) {
    TIM_HandleTypeDef *htim = &irremote->htim;

    if(__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET) {
      if(__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET) {
        __HAL_TIM_CLEAR_IT(htim, TIM_IT_UPDATE);
            htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

        PeriodElapsedCallback(irremote);
      }
    }
    HAL_TIM_IRQHandler(htim);
  }
  else if(irq == DMA1_Channel1_IRQn
      ||  irq == DMA1_Channel2_IRQn
      ||  irq == DMA1_Channel3_IRQn
      ||  irq == DMA1_Channel4_IRQn
      ||  irq == DMA1_Channel5_IRQn
      ||  irq == DMA1_Channel6_IRQn
      ||  irq == DMA1_Channel7_IRQn
      ) {
    HAL_DMA_IRQHandler(&irremote->dma_pulse);
    HAL_DMA_IRQHandler(&irremote->dma_width);
  }
}

bool CM_HAL_IRREMOTE_Decode(struct CM_HAL_IRREMOTE *irremote, struct decode_results_t *results)
{
  if(irremote->rcvstate != IRREMOTE_DONE)
    return false;

  int len_data_width =  IRREMOTE_RAWBUF/2 - __HAL_DMA_GET_COUNTER(&irremote->dma_width);
  int len_data_pulse =  IRREMOTE_RAWBUF/2 - __HAL_DMA_GET_COUNTER(&irremote->dma_pulse);

  if(len_data_width == 0 || len_data_pulse == 0)
    return false;

  irremote->rawlen = 1;
  irremote->rawbuf[0] = irremote->data_width[0];
  for(int i=0; i<len_data_pulse; ++i) {
    irremote->rawbuf[irremote->rawlen++] = irremote->data_pulse[i];
    irremote->rawbuf[irremote->rawlen++] = irremote->data_width[i+1]-irremote->data_pulse[i];
  }

	results->rawbuf = irremote->rawbuf;
	results->rawlen = irremote->rawlen;
	results->overflow = __HAL_DMA_GET_COUNTER(&irremote->dma_width) == 0 || __HAL_DMA_GET_COUNTER(&irremote->dma_pulse) == 0;
	irremote->rcvstate = IRREMOTE_READY;

#if DECODE_NEC
	if(decodeNEC(results))
		return true;
#endif

#if DECODE_SONY
	if(decodeSony(results))
		return true;
#endif

#if DECODE_SANYO
	if(decodeSanyo(results))
		return true;
#endif

#if DECODE_MITSUBISHI
	if(decodeMitsubishi(results))
		return true;
#endif

#if DECODE_RC5
	if(decodeRC5(results))
		return true;
#endif

#if DECODE_RC6
	if(decodeRC6(results))
		return true;
#endif

#if DECODE_PANASONIC
	if(decodePanasonic(results))
		return true;
#endif

#if DECODE_LG
	if(decodeLG(results))
		return true;
#endif

#if DECODE_JVC
	if(decodeJVC(results))
		return true;
#endif

#if DECODE_SAMSUNG
	if(decodeSAMSUNG(results))
		return true;
#endif

#if DECODE_WHYNTER
	if(decodeWhynter(results))
		return true;
#endif

#if DECODE_AIWA_RC_T501
	if(decodeAiwaRCT501(results))
		return true;
#endif

#if DECODE_DENON
	if(decodeDenon(results))
		return true;
#endif

	if(decodeHash(results))
		return true;

	return false;
}


__attribute__((weak)) void assert_failed(uint8_t* file, uint32_t line)
{
	for(;;) {
		__NOP();
	}
}
