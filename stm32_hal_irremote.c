/**
 ******************************************************************************
 * @file     lib.c
 * @author   Auto-generated by STM32CubeIDE
 * @version  V1.0
 * @date     08/12/2021 21:02:36
 * @brief    Default under dev library file.
 ******************************************************************************
 */

/* Includes ------------------------------------------------------------------*/
#include "stm32_hal_irremote.h"
#include "decoders/decoders.h"

/** Functions ----------------------------------------------------------------*/
static void EnableTIM(TIM_TypeDef *tim)
{
	switch ((uintptr_t) tim) {
	case TIM2_BASE:
		__HAL_RCC_TIM2_CLK_ENABLE();
		break;
	case TIM3_BASE:
		__HAL_RCC_TIM3_CLK_ENABLE();
		break;
	case TIM4_BASE:
		__HAL_RCC_TIM4_CLK_ENABLE();
		break;
	}
}

static void EnableTIM_IRQ(TIM_TypeDef *tim)
{
	IRQn_Type irq;
	switch ((uintptr_t) tim) {
	case TIM2_BASE:
		irq = TIM2_IRQn;
		break;
	case TIM3_BASE:
		irq = TIM3_IRQn;
		break;
	case TIM4_BASE:
		irq = TIM4_IRQn;
		break;
	default:
		return;
	}

	HAL_NVIC_SetPriority(irq, 0, 0);
	HAL_NVIC_EnableIRQ(irq);
}

static void EnableGPIO(GPIO_TypeDef *gpio)
{
	switch ((uintptr_t) gpio) {
	case GPIOA_BASE:
		__HAL_RCC_GPIOA_CLK_ENABLE();
		break;
	case GPIOB_BASE:
		__HAL_RCC_GPIOB_CLK_ENABLE();
		break;
	}
}

static int GetTIMPrescaler()
{
	int ret = (HAL_RCC_GetPCLK2Freq() / 1000000) * IR_USECPERTICK - 1;
	if (ret < 0)
		return 0;
	return ret;
}

static void InitGPIO(struct CM_HAL_IRREMOTE *irremote)
{
	switch ((uintptr_t) irremote->htim.Instance) {
#if defined(STM32F1)
	case TIM1_BASE:
		irremote->GPIOx = GPIOA;
		irremote->GPIO_Pin = GPIO_PIN_8;
		break;
	case TIM2_BASE:
		irremote->GPIOx = GPIOA;
		irremote->GPIO_Pin = GPIO_PIN_0;
		break;
	case TIM3_BASE:
		irremote->GPIOx = GPIOA;
		irremote->GPIO_Pin = GPIO_PIN_6;
		break;
	case TIM4_BASE:
		irremote->GPIOx = GPIOB;
		irremote->GPIO_Pin = GPIO_PIN_6;
		break;
#else
#error "STM32 controller is not defined or not supported (yet)"
#endif
	default:
		assert_param(0);
	}

	EnableGPIO(irremote->GPIOx);
	GPIO_InitTypeDef GPIO_InitStruct = { .Pin = irremote->GPIO_Pin, .Mode = GPIO_MODE_INPUT, .Pull =
			GPIO_NOPULL };
	HAL_GPIO_Init(irremote->GPIOx, &GPIO_InitStruct);
}

static void InitTIM(struct CM_HAL_IRREMOTE *irremote, TIM_TypeDef *tim)
{
	TIM_HandleTypeDef *htim = &irremote->htim;
	htim->Instance = tim;
	EnableTIM(htim->Instance);
	htim->Init.Prescaler = GetTIMPrescaler();
	htim->Init.CounterMode = TIM_COUNTERMODE_UP;
	htim->Init.Period = IR_GAP_TICKS; // 50 usec
	htim->Init.ClockDivision = TIM_CLOCKDIVISION_DIV1;
	htim->Init.AutoReloadPreload = TIM_AUTORELOAD_PRELOAD_DISABLE;
	if (HAL_TIM_Base_Init(htim) != HAL_OK) {
		assert_param(0);
	}
	TIM_ClockConfigTypeDef sClockSourceConfig = { .ClockSource = TIM_CLOCKSOURCE_INTERNAL,
			.ClockFilter = 0, .ClockPolarity = 0, .ClockPrescaler = 0 };
	if (HAL_TIM_ConfigClockSource(htim, &sClockSourceConfig) != HAL_OK) {
		assert_param(0);
	}
	if (HAL_TIM_IC_Init(htim) != HAL_OK) {
		assert_param(0);
	}
	TIM_SlaveConfigTypeDef sSlaveConfig = { .SlaveMode = TIM_SLAVEMODE_RESET, .InputTrigger =
			TIM_TS_TI1FP1, .TriggerPolarity = TIM_INPUTCHANNELPOLARITY_FALLING, .TriggerFilter = 0,
			.TriggerPrescaler = 0 };
	if (HAL_TIM_SlaveConfigSynchro(htim, &sSlaveConfig) != HAL_OK) {
		assert_param(0);
	}
	TIM_MasterConfigTypeDef sMasterConfig = { .MasterOutputTrigger = TIM_TRGO_RESET,
			.MasterSlaveMode = TIM_MASTERSLAVEMODE_DISABLE };
	if (HAL_TIMEx_MasterConfigSynchronization(htim, &sMasterConfig) != HAL_OK) {
		assert_param(0);
	}
	TIM_IC_InitTypeDef sConfigIC = { .ICPolarity = TIM_INPUTCHANNELPOLARITY_FALLING, .ICSelection =
			TIM_ICSELECTION_DIRECTTI, .ICPrescaler = TIM_ICPSC_DIV1, .ICFilter = 0 };
	if (HAL_TIM_IC_ConfigChannel(htim, &sConfigIC, TIM_CHANNEL_1) != HAL_OK) {
		assert_param(0);
	}
	sConfigIC.ICPolarity = TIM_INPUTCHANNELPOLARITY_RISING;
	sConfigIC.ICSelection = TIM_ICSELECTION_INDIRECTTI;
	if (HAL_TIM_IC_ConfigChannel(htim, &sConfigIC, TIM_CHANNEL_2) != HAL_OK) {
		assert_param(0);
	}

	EnableTIM_IRQ(htim->Instance);
}

static DMA_Channel_TypeDef* GetDMAInstance(TIM_TypeDef *tim, uint16_t DMAHandleIndex)
{
#if defined(STM32F1)
	switch ((uintptr_t) tim) {
	case TIM2_BASE:
		switch (DMAHandleIndex) {
		case TIM_DMA_ID_CC1:
			return DMA1_Channel5;
		case TIM_DMA_ID_CC2:
			return DMA1_Channel7;
		default:
			return NULL;
		}
	case TIM4_BASE:
		switch (DMAHandleIndex) {
		case TIM_DMA_ID_CC1:
			return DMA1_Channel1;
		case TIM_DMA_ID_CC2:
			return DMA1_Channel4;
		default:
			return NULL;
		}
	default:
		return NULL;
	}
#endif
	return NULL;
}

static void EnableDMA_IRQ(DMA_Channel_TypeDef *dmaChannel)
{
	IRQn_Type irq;
#if defined(STM32F1)
	int dmaIndex = (((uintptr_t) dmaChannel) - DMA1_Channel1_BASE) / 0x14;
	irq = DMA1_Channel1_IRQn + dmaIndex;
#endif
	HAL_NVIC_SetPriority(irq, 0, 0);
	HAL_NVIC_EnableIRQ(irq);
}

static void InitDMA(struct CM_HAL_IRREMOTE *irremote)
{
	__HAL_RCC_DMA1_CLK_ENABLE();

	irremote->dma_width.Instance = GetDMAInstance(irremote->htim.Instance, TIM_DMA_ID_CC1);
	if (!irremote->dma_width.Instance)
		return;
	irremote->dma_width.Init.Direction = DMA_PERIPH_TO_MEMORY;
	irremote->dma_width.Init.PeriphInc = DMA_PINC_DISABLE;
	irremote->dma_width.Init.MemInc = DMA_MINC_ENABLE;
	irremote->dma_width.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
	irremote->dma_width.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
	irremote->dma_width.Init.Mode = DMA_NORMAL;
	irremote->dma_width.Init.Priority = DMA_PRIORITY_LOW;
	if (HAL_DMA_Init(&irremote->dma_width) != HAL_OK) {
		assert_param(0);
	}
	__HAL_LINKDMA(&(irremote->htim), hdma[TIM_DMA_ID_CC1], irremote->dma_width);

	irremote->dma_pulse.Instance = GetDMAInstance(irremote->htim.Instance, TIM_DMA_ID_CC2);
	if (!irremote->dma_pulse.Instance)
		return;
	irremote->dma_pulse.Init.Direction = DMA_PERIPH_TO_MEMORY;
	irremote->dma_pulse.Init.PeriphInc = DMA_PINC_DISABLE;
	irremote->dma_pulse.Init.MemInc = DMA_MINC_ENABLE;
	irremote->dma_pulse.Init.PeriphDataAlignment = DMA_PDATAALIGN_HALFWORD;
	irremote->dma_pulse.Init.MemDataAlignment = DMA_MDATAALIGN_HALFWORD;
	irremote->dma_pulse.Init.Mode = DMA_NORMAL;
	irremote->dma_pulse.Init.Priority = DMA_PRIORITY_LOW;
	if (HAL_DMA_Init(&irremote->dma_pulse) != HAL_OK) {
		assert_param(0);
	}
	__HAL_LINKDMA(&(irremote->htim), hdma[TIM_DMA_ID_CC2], irremote->dma_pulse);

	EnableDMA_IRQ(irremote->dma_width.Instance);
	EnableDMA_IRQ(irremote->dma_pulse.Instance);

}

static inline uint8_t IsIRRemoteDMA(struct CM_HAL_IRREMOTE *irremote)
{
	return (irremote->htim.Instance->DIER & TIM_DMA_CC1) != 0
			&& (irremote->htim.Instance->DIER & TIM_DMA_CC2) != 0;
}

void CM_HAL_IRREMOTE_Init(struct CM_HAL_IRREMOTE *irremote, TIM_TypeDef *tim)
{
	assert_param(IS_TIM_CC1_INSTANCE(tim));
	assert_param(IS_TIM_CC2_INSTANCE(tim));

	InitTIM(irremote, tim);

	InitGPIO(irremote);
	InitDMA(irremote);
}

static void CommonStart(struct CM_HAL_IRREMOTE *irremote)
{
	irremote->rcvstate = IRREMOTE_CAPTURE;
	irremote->rawlen = 0;
	irremote->data_width_len = 0;
	irremote->data_pulse_len = 0;
	irremote->overflow = 0;
	__HAL_TIM_URS_ENABLE(&irremote->htim);
}

void CM_HAL_IRREMOTE_Start_DMA(struct CM_HAL_IRREMOTE *irremote)
{
	assert_param(IS_DMA_ALL_INSTANCE(irremote->dma_pulse.Instance));
	assert_param(IS_DMA_ALL_INSTANCE(irremote->dma_width.Instance));

	CommonStart(irremote);

	HAL_TIM_IC_Start_DMA(&irremote->htim, TIM_CHANNEL_1, (uint32_t*) irremote->data_width,
			IRREMOTE_RAWBUF / 2);
	HAL_TIM_IC_Start_DMA(&irremote->htim, TIM_CHANNEL_2, (uint32_t*) irremote->data_pulse,
			IRREMOTE_RAWBUF / 2);
	HAL_TIM_Base_Start_IT(&irremote->htim);
}

void CM_HAL_IRREMOTE_Start_IT(struct CM_HAL_IRREMOTE *irremote)
{
	CommonStart(irremote);

	HAL_TIM_IC_Start_IT(&irremote->htim, TIM_CHANNEL_1);
	HAL_TIM_IC_Start_IT(&irremote->htim, TIM_CHANNEL_2);
	HAL_TIM_Base_Start_IT(&irremote->htim);
}

void CM_HAL_IRREMOTE_Stop_DMA(struct CM_HAL_IRREMOTE *irremote)
{
	assert_param(IsIRRemoteDMA(irremote));

	irremote->rcvstate = IRREMOTE_DONE;
	HAL_TIM_IC_Stop_DMA(&irremote->htim, TIM_CHANNEL_1);
	HAL_TIM_IC_Stop_DMA(&irremote->htim, TIM_CHANNEL_2);
	HAL_TIM_Base_Stop_IT(&irremote->htim);
	irremote->data_pulse_len = (IRREMOTE_RAWBUF / 2) - __HAL_DMA_GET_COUNTER(&irremote->dma_pulse);
	irremote->data_width_len = (IRREMOTE_RAWBUF / 2) - __HAL_DMA_GET_COUNTER(&irremote->dma_width);
}

void CM_HAL_IRREMOTE_Stop_IT(struct CM_HAL_IRREMOTE *irremote)
{
	assert_param(!IsIRRemoteDMA(irremote));

	irremote->rcvstate = IRREMOTE_DONE;
	HAL_TIM_IC_Stop_IT(&irremote->htim, TIM_CHANNEL_1);
	HAL_TIM_IC_Stop_IT(&irremote->htim, TIM_CHANNEL_2);
	HAL_TIM_Base_Stop_IT(&irremote->htim);
}

static void PeriodElapsedCallback(struct CM_HAL_IRREMOTE *irremote)
{
	switch (irremote->rcvstate) {
	case IRREMOTE_DONE:
	case IRREMOTE_READY:
		// Oops?
		return;
	case IRREMOTE_CAPTURE: {
		// GAP found!
		int len = 0;
		if (IsIRRemoteDMA(irremote)) {
			len = (IRREMOTE_RAWBUF / 2) - __HAL_DMA_GET_COUNTER(&irremote->dma_pulse);
		}
		else {
			len = irremote->data_pulse_len;
		}
		if (len > 0) {
			// At least one pulse has been captured

			// probably obsolete:
//			// switch to GAP state
//	    irremote->rcvstate = IRREMOTE_GAP;
//	    // force measuring of space (we will not count on it)
//	    HAL_TIM_GenerateEvent(&irremote->htim, TIM_EVENTSOURCE_CC1);
//	    // force one more update, to have correct number of measurements
//	    HAL_TIM_GenerateEvent(&irremote->htim, TIM_EVENTSOURCE_UPDATE);

			if (IsIRRemoteDMA(irremote)) {
				CM_HAL_IRREMOTE_Stop_DMA(irremote);
			}
			else {
				CM_HAL_IRREMOTE_Stop_IT(irremote);
			}
		}
		return;
	}
	case IRREMOTE_GAP:
		if (IsIRRemoteDMA(irremote)) {
			CM_HAL_IRREMOTE_Stop_DMA(irremote);
		}
		else {
			CM_HAL_IRREMOTE_Stop_IT(irremote);
		}
		return;
	}
}

static void CaptureCallback(struct CM_HAL_IRREMOTE *irremote)
{
	TIM_HandleTypeDef *htim = &irremote->htim;
	switch (HAL_TIM_GetActiveChannel(htim)) {
	case HAL_TIM_ACTIVE_CHANNEL_1:
		irremote->data_width[irremote->data_width_len++] = htim->Instance->CCR1;
		break;
	case HAL_TIM_ACTIVE_CHANNEL_2:
		irremote->data_pulse[irremote->data_pulse_len++] = htim->Instance->CCR2;
		break;
	default:
		break;
	}
}

void CM_HAL_IRREMOTE_IRQHandler(struct CM_HAL_IRREMOTE *irremote, IRQn_Type irq)
{
	if (irq == TIM2_IRQn || irq == TIM3_IRQn || irq == TIM4_IRQn) {
		TIM_HandleTypeDef *htim = &irremote->htim;

		/* Capture compare 1 event */
		if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC1) != RESET) {
			if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC1) != RESET) {
				{
					htim->Channel = HAL_TIM_ACTIVE_CHANNEL_1;

					/* Input capture event */
					if ((htim->Instance->CCMR1 & TIM_CCMR1_CC1S) != 0x00U) {
						CaptureCallback(irremote);
					}
					/* Output compare event */
					htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
				}
			}
		}
		/* Capture compare 2 event */
		if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_CC2) != RESET) {
			if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_CC2) != RESET) {
				htim->Channel = HAL_TIM_ACTIVE_CHANNEL_2;
				/* Input capture event */
				if ((htim->Instance->CCMR1 & TIM_CCMR1_CC2S) != 0x00U) {
					CaptureCallback(irremote);
				}
				htim->Channel = HAL_TIM_ACTIVE_CHANNEL_CLEARED;
			}
		}

		/* TIM Update event */
		if (__HAL_TIM_GET_FLAG(htim, TIM_FLAG_UPDATE) != RESET) {
			if (__HAL_TIM_GET_IT_SOURCE(htim, TIM_IT_UPDATE) != RESET) {
				PeriodElapsedCallback(irremote);
			}
		}

		// Pass to HAL TIM IRQHandler
		HAL_TIM_IRQHandler(htim);
	}
	else if (irq == DMA1_Channel1_IRQn || irq == DMA1_Channel2_IRQn || irq == DMA1_Channel3_IRQn
			|| irq == DMA1_Channel4_IRQn || irq == DMA1_Channel5_IRQn || irq == DMA1_Channel6_IRQn
			|| irq == DMA1_Channel7_IRQn) {
		HAL_DMA_IRQHandler(&irremote->dma_pulse);
		HAL_DMA_IRQHandler(&irremote->dma_width);
	}
}

uint8_t CM_HAL_IRREMOTE_Decode(struct CM_HAL_IRREMOTE *irremote, struct decode_results_t *results)
{
	if (irremote->rcvstate != IRREMOTE_DONE)
		return 0;

	if (irremote->data_width_len == 0 || irremote->data_pulse_len == 0)
		return 0;

	irremote->rawlen = 1;
	irremote->rawbuf[0] = irremote->data_width[0];
	for (int i = 0; i < irremote->data_pulse_len; ++i) {
		irremote->rawbuf[irremote->rawlen++] = irremote->data_pulse[i];
		irremote->rawbuf[irremote->rawlen++] = irremote->data_width[i + 1] - irremote->data_pulse[i];
	}
	irremote->rawlen--;

	results->rawbuf = irremote->rawbuf;
	results->rawlen = irremote->rawlen;
	results->overflow = (irremote->data_width_len == IRREMOTE_RAWBUF / 2)
			|| (irremote->data_pulse_len == IRREMOTE_RAWBUF / 2);
	irremote->rcvstate = IRREMOTE_READY;

#if DECODE_NEC
	if (decodeNEC(results))
		return 1;
#endif

#if DECODE_SONY
	if(decodeSony(results))
		return 1;
#endif

#if DECODE_SANYO
	if(decodeSanyo(results))
		return 1;
#endif

#if DECODE_MITSUBISHI
	if(decodeMitsubishi(results))
		return 1;
#endif

#if DECODE_RC5
	if (decodeRC5(results))
		return 1;
#endif

#if DECODE_RC6
	if (decodeRC6(results))
		return 1;
#endif

#if DECODE_PANASONIC
	if(decodePanasonic(results))
		return 1;
#endif

#if DECODE_LG
	if(decodeLG(results))
		return 1;
#endif

#if DECODE_JVC
	if(decodeJVC(results))
		return 1;
#endif

#if DECODE_SAMSUNG
	if(decodeSAMSUNG(results))
		return 1;
#endif

#if DECODE_WHYNTER
	if(decodeWhynter(results))
		return 1;
#endif

#if DECODE_AIWA_RC_T501
	if(decodeAiwaRCT501(results))
		return 1;
#endif

#if DECODE_DENON
	if(decodeDenon(results))
		return 1;
#endif

	if (decodeHash(results))
		return 1;

	return 0;
}

__attribute__((weak)) void assert_failed(uint8_t *file, uint32_t line)
{
	for (;;) {
		__NOP();
	}
}
